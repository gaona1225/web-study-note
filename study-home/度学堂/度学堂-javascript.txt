对象类型
基本类型：number, string, boolean,undefined, null
对象类型：object,function

对象分为：原生对象（包括一部分内置对象、本地对象）、宿主对象
本地对象：由ECMA标准规定的对象视胨拗魑薰
内置对象：在程度开始执行前就构造完毕的本地对象，所有内置对象都是原生对象
宿主对象：宿主提供的时曜济挥泄娑ǖ亩韵 

内置对象：
构造器：String Number Boolean Object Function Date Array RegExp
静态对象：Global Math JSON
错误对象：Error EvalError RangeError ReferenceError SyntexError TypeErro URIError
1、EvalError: 错误发生在eval()函数中
2、RangeError:数字的值超过javascript可表示的范围
3、ReferenceError: 使用了非法的引用
4、SyntaxError: 在eval()函数调用中发生了语法错误。
5、TypeError:变量的类型不是预期所需的
6、URIError: 在encodeURI()或者decodeURI()函数中发生的错误

javascript是作为源代码下载，然后浏览器对其进行 解释的(不存在编译问题),因此javascript的性能就体现在速度方法，而速度又被分割成两部分：下载时间和执行速度
1、下载时间： 使用java等其他语言我们可以不必考虑100个字符长的变量名及大量的注释.因为这些在编译后名称会被替换掉，注释也会被自动删除，但javascript开发人员，就没有这么爽了!（可以对源代码进行压缩）
增加下载时间的关键因素是脚本所包含的字节数.记住一个关键数字1160;这是能放入单个TCP-IP包中的字节数。最好能将每个javascript文件都保持在1160字节以下以获取最优的下载时间
减小代码下载的时间方法：
删除注释
删除制表符和空格
删除所有的换行
替换变量名
替换布尔值：true等于1,false等于0.因此脚本包含的字面量true都可以用1来替换，而false可以用0替换
使用数组和对象字面量：var aTest = new Array(); => var aTest = [ ]; //相当于新建一个空数组，var oTest = new Object();=> var oTest = {};
2、执行时间
使用局部变量： 如果直接使用变量而不事先使用var进行声明，变量就会创建在window范围内，解释程序就会搜索整个范围树
避免with语句：范围越少，速度越快，这是不使用with语句的原因
计算机科学基础：选择正确的算法，反转循环.速度要块for(var i=0;i<aValues.length;i++){}=>for(var i=aValues.length;i>=0;i--){}
其他：避免字符串连结，通过自己的封装的方法（例如数组push最后将数组转换成字符串），优先使用内置方法，存储常用的值，节约使用DOM

console.log(typeof NaN  === 'number' ) //output true
NaN参与所有数学运算的结果都是NaN 


清空数组:
1、array = [] ∷俣茸羁欤生成了新对象，原有数组需要垃圾回收，在GC发生时影响效率，不易频繁使用 
2、array.length = 0 ∷俣嚷月，不生成新对象，对GC没有影响
3、while (array.length) array.pop(); ∷俣茸盥写码最多 


console.log(typeof []); //output object
console.log(Object.prototype.toString.call([]));  //output [object Array] 
 
 
作用域：
var x = 1; 
function outer() {     
	var y = 2;     
	return (function(){         
		var z = 3;         
		alert([x, y, z]);     
	} )
} 
outer()() //output 1,2,3

var x = 1; 
function outer() {     
	var y = 2;   
	inner();  
	function inner(){         
		var z = 3;         
		alert([x, y, z]);     
	}
} 
outer() //output 1,2,3


function fn() {     
	eval('var x = 3');     
	window.eval('var y = 4');     
	alert([x, y]); 
} 
fn();  //3,4
alert(x);  //x未定义
alert(y); // 4 

var x = 1; 
function fn() {     
	var y = 2;     
	new Function('alert(x);')();  //1
	new Function('alert(y);')(); //报错--y未定义， new Function()需要跳出fn(0
} 
fn(); 


this
window.x = 'fn'; 
var o = {     
	fn: function() {         
		return function() {             
			alert(this.x);         
		};     
	} 
}; 
function getName() { 
	return this.x; 
}
o.fn()()//fn  this都是指向全局的window.x
console.log(getName()); //fn this都是指向全局的window.x
o[getName()]().call({ x: 1 }); //1  getName()函数调用window返回this.x => fn => o['fn']()调用o对象中的fn=》再进过call调用走向o中的fn里return方法


遗留问题：
new function() {     
	do {         
		debugger; break     
	} while (typeof delete this);     
	for (var a; void 0;)         
		continue     
	if (null)         
		with (0)     
	try {         
		switch (1 in 1 instanceof 1) {             
			case false:             
			default: throw true         
		}     
	}     
	catch (a) {}     
	finally {}     
	else return
};


var proto = y.prototype; 
while (proto && proto !== x.__proto__) {     
	proto = proto.__proto__; 
} 
console.log(proto);
return proto === x.__proto__; 


生成100个x Array(101).join('x') ∮糜诳焖偕成超大对象测试内存问题 〕ざ炔荒芴大5亿-6亿之间 

原型链查找：
function getProperty(o, name) {     
	while (o) {         
		if (hasProperty(o, name)) {             
			return o[name];         
		}         
		o = o.__proto__;     
	}     
	return undefined;
}


var fn = function sequence(x) {     
	console.log(x); 
	 x > 0 && sequence(x - 1);  
} 
alert(fn); // function 
alert(sequence); // ReferenceError除IE6-8  


this
window.x = 'fn'; 
var o = {     
	fn: function() {         
		return function() {             
			alert(this.x);         
		};     
	} 
}; 
function getName() { 
	return this.x; 
}
o.fn()()//fn  this都是指向全局的window.x
console.log(getName()); //fn this都是指向全局的window.x
o[getName()]().call({ x: 1 }); //1  getName()函数调用window返回this.x => fn => o['fn']()调用o对象中的fn=》再进过call调用走向o中的fn里return方法
